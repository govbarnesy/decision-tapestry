#!/usr/bin/env node

/**
 * Claude Code DOM Editor Integration
 * 
 * This integration automatically handles DOM element removal requests
 * by creating tasks for Claude Code to execute.
 * 
 * Usage: node claude-code-integration/dom-editor-integration.mjs
 */

import WebSocket from 'ws';
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import { spawn } from 'child_process';

class ClaudeCodeDOMIntegration {
  constructor() {
    this.ws = null;
    this.projectRoot = process.cwd();
    this.isProcessing = false;
    this.claudeTaskFile = path.join(this.projectRoot, '.claude-dom-task.md');
  }

  async start() {
    console.log(chalk.blue('ü§ñ Claude Code DOM Editor Integration Started'));
    console.log(chalk.gray(`Project root: ${this.projectRoot}`));
    console.log(chalk.gray('Monitoring for DOM element removal requests...\n'));

    // Create CLAUDE.md if it doesn't exist
    await this.ensureClaudeInstructions();
    
    this.connect();
  }

  async ensureClaudeInstructions() {
    const claudeMdPath = path.join(this.projectRoot, 'CLAUDE.md');
    
    try {
      await fs.access(claudeMdPath);
    } catch {
      // Create CLAUDE.md with DOM editor instructions
      const instructions = `# Claude Code Integration - DOM Editor

## DOM Element Removal

When you see a file named \`.claude-dom-task.md\`, it contains a request to remove a DOM element from the codebase.

### Process:
1. Read the task file for element details
2. Search the codebase for the element
3. Remove it from the source code
4. Delete the task file when complete
5. The DOM Editor will automatically update the browser

### Important:
- Always search thoroughly - elements might be in components, templates, or generated code
- Check for associated event handlers, styles, and state
- Ensure removal doesn't break functionality
- If unsure, ask for clarification
`;
      
      await fs.writeFile(claudeMdPath, instructions);
      console.log(chalk.green('‚úÖ Created CLAUDE.md with DOM editor instructions'));
    }
  }

  connect() {
    this.ws = new WebSocket('ws://localhost:8080');

    this.ws.on('open', () => {
      console.log(chalk.green('‚úÖ Connected to Decision Tapestry server'));
      
      // Register as a Claude Code integration
      this.ws.send(JSON.stringify({
        type: 'integration_connect',
        integrationType: 'claude_code_dom_editor',
        projectRoot: this.projectRoot,
        capabilities: ['code_removal', 'element_search']
      }));
    });

    this.ws.on('message', async (data) => {
      try {
        const message = JSON.parse(data.toString());
        
        if (message.type === 'code_removal_requested') {
          await this.handleCodeRemovalRequest(message);
        }
      } catch (error) {
        console.error(chalk.red('Error processing message:'), error);
      }
    });

    this.ws.on('close', () => {
      console.log(chalk.yellow('‚ö†Ô∏è  Connection closed. Reconnecting in 5s...'));
      setTimeout(() => this.connect(), 5000);
    });
  }

  async handleCodeRemovalRequest(data) {
    const { element, url, sessionId } = data;
    
    if (this.isProcessing) {
      console.log(chalk.yellow('‚è≥ Already processing a request...'));
      return;
    }

    this.isProcessing = true;

    console.log(chalk.cyan('\nüéØ ELEMENT REMOVAL REQUEST'));
    console.log(chalk.cyan('=========================='));
    console.log('Element:', chalk.yellow(`${element.tagName}${element.id ? '#' + element.id : ''}`));
    console.log('Page:', chalk.blue(url));
    
    // Create task for Claude Code
    const task = this.createClaudeTask(element, url);
    await fs.writeFile(this.claudeTaskFile, task);
    
    console.log(chalk.green('\nüìù Task created for Claude Code'));
    console.log(chalk.gray('Claude Code will now:'));
    console.log(chalk.gray('1. Detect the new task file'));
    console.log(chalk.gray('2. Search for and remove the element'));
    console.log(chalk.gray('3. Delete the task file when done'));
    
    // Monitor for task completion
    await this.monitorTaskCompletion(element, sessionId);
  }

  createClaudeTask(element, url) {
    const { context } = element;
    
    return `# DOM Element Removal Task

**Generated by**: DOM Editor Extension
**Time**: ${new Date().toISOString()}
**Page**: ${url}

## Element to Remove

### Identification
- **Tag**: \`${element.tagName}\`
- **ID**: \`${element.id || 'none'}\`
- **Classes**: \`${element.className || 'none'}\`
- **Selector**: \`${element.selector}\`

### Search Hints
${this.generateSearchHints(element)}

### Context
${this.formatContext(context)}

### HTML Structure
\`\`\`html
${element.outerHTML || element.innerHTML || 'No HTML available'}
\`\`\`

### Instructions
1. Search for this element across all source files
2. Common patterns to look for:
   - JSX: \`<${element.tagName} id="${element.id}" className="${element.className}">\`
   - Vue: \`<${element.tagName} id="${element.id}" class="${element.className}">\`
   - Template literals with the HTML
   - Component files that might generate this element
3. Remove the element and cleanup:
   - Delete the element itself
   - Remove associated event handlers
   - Remove associated styles
   - Remove any state/props specific to this element
4. Verify the app still works after removal
5. **Delete this task file when complete**

### Important Notes
- Be thorough - the element might be conditionally rendered
- Check for dynamic class names or IDs
- Look for partial matches if exact matches aren't found
- If you can't find it, note where you searched

---
**Auto-generated task - Delete this file after completion**
`;
  }

  generateSearchHints(element) {
    const hints = [];
    
    // ID-based searches
    if (element.id) {
      hints.push(`- Search for: id="${element.id}" or id={'${element.id}'} or id={\`${element.id}\`}`);
      hints.push(`- Search for: #${element.id} in CSS files`);
      hints.push(`- Search for: getElementById('${element.id}') or querySelector('#${element.id}')`);
    }
    
    // Class-based searches
    if (element.className) {
      const classes = element.className.split(' ').filter(c => c);
      hints.push(`- Search for: className="${element.className}" or class="${element.className}"`);
      classes.forEach(cls => {
        hints.push(`- Search for: .${cls} in CSS files`);
        hints.push(`- Search for: getElementsByClassName('${cls}') or querySelector('.${cls}')`);
      });
    }
    
    // Tag-based searches
    hints.push(`- Search for: <${element.tagName} variations`);
    
    // Text content searches
    if (element.text && element.text.length > 10) {
      const textSnippet = element.text.substring(0, 50).trim();
      hints.push(`- Search for text content: "${textSnippet}"`);
    }
    
    // Data attribute searches
    if (element.attributes) {
      Object.entries(element.attributes).forEach(([key, value]) => {
        if (key.startsWith('data-') || key === 'aria-label') {
          hints.push(`- Search for: ${key}="${value}"`);
        }
      });
    }
    
    return hints.length > 0 ? hints.join('\n') : '- No specific search hints available';
  }

  formatContext(context) {
    if (!context) return 'No context available';
    
    let formatted = '';
    
    if (context.parentChain?.length > 0) {
      formatted += '**Parent Hierarchy:**\n```\n';
      context.parentChain.forEach((parent, index) => {
        const indent = '  '.repeat(index);
        formatted += `${indent}${parent.tagName}`;
        if (parent.id) formatted += `#${parent.id}`;
        if (parent.className) formatted += `.${parent.className.split(' ')[0]}`;
        formatted += '\n';
      });
      formatted += '```\n\n';
    }
    
    if (context.siblingContext) {
      formatted += `**Position:** Element ${context.siblingContext.index + 1} of ${context.siblingContext.totalSiblings} siblings\n\n`;
    }
    
    if (context.filePath) {
      formatted += `**Possible source:** ${context.filePath}\n`;
    }
    
    return formatted;
  }

  async monitorTaskCompletion(element, sessionId) {
    console.log(chalk.blue('\n‚è≥ Monitoring for task completion...'));
    
    let checkCount = 0;
    const maxChecks = 120; // 10 minutes max
    
    const checkInterval = setInterval(async () => {
      checkCount++;
      
      try {
        // Check if task file still exists
        try {
          await fs.access(this.claudeTaskFile);
          // File still exists, task not complete
          
          if (checkCount % 12 === 0) { // Every minute
            console.log(chalk.gray(`‚è≥ Still waiting... (${Math.floor(checkCount * 5 / 60)} minutes elapsed)`));
          }
        } catch {
          // File doesn't exist - task completed!
          console.log(chalk.green('\n‚úÖ Task completed! Claude Code has removed the element.'));
          
          // Notify server
          this.ws.send(JSON.stringify({
            type: 'code_removal_complete',
            sessionId: sessionId,
            element: `${element.tagName}${element.id ? '#' + element.id : ''}`,
            method: 'claude_code_automated',
            success: true
          }));
          
          clearInterval(checkInterval);
          this.isProcessing = false;
          
          console.log(chalk.green('‚úÖ Element removal confirmed!'));
          console.log(chalk.gray('\nReady for next request...\n'));
        }
      } catch (error) {
        console.error(chalk.red('Error checking task status:'), error);
      }
      
      if (checkCount >= maxChecks) {
        console.log(chalk.yellow('\n‚è±Ô∏è  Timeout waiting for task completion'));
        console.log(chalk.yellow('Claude Code may still be working on it...'));
        clearInterval(checkInterval);
        this.isProcessing = false;
        
        // Don't delete the task file on timeout
      }
    }, 5000); // Check every 5 seconds
  }
}

// Start the integration
const integration = new ClaudeCodeDOMIntegration();
integration.start();

// Handle graceful shutdown
process.on('SIGINT', async () => {
  console.log(chalk.yellow('\n\nüëã Shutting down Claude Code DOM Integration...'));
  
  // Clean up task file if it exists
  try {
    await fs.unlink(integration.claudeTaskFile);
    console.log(chalk.gray('Cleaned up task file'));
  } catch {}
  
  if (integration.ws) {
    integration.ws.close();
  }
  process.exit(0);
});