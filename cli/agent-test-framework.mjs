/**
 * Agent Test Framework
 * Automatically generates and runs tests for agent work
 */

import { promises as fs } from 'fs';
import path from 'path';
import { spawn } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class AgentTestFramework {
    constructor(agentId) {
        this.agentId = agentId;
        this.testDir = path.resolve(__dirname, '../__tests__/agents');
        this.testFile = path.join(this.testDir, `agent-${agentId}.test.ts`);
        this.integrationTestFile = path.join(this.testDir, `agent-${agentId}-integration.test.ts`);
        this.tests = [];
        this.testResults = {
            passed: 0,
            failed: 0,
            total: 0,
            details: []
        };
    }

    /**
     * Initialize test framework
     */
    async initialize() {
        try {
            // Ensure test directory exists
            await fs.mkdir(this.testDir, { recursive: true });
            
            // Initialize test file
            await this.initializeTestFile();
            
            this.log('Test framework initialized');
        } catch (error) {
            throw new Error(`Failed to initialize test framework: ${error.message}`);
        }
    }

    /**
     * Initialize test file with basic structure
     */
    async initializeTestFile() {
        const testContent = `/**
 * Auto-generated tests for Agent-${this.agentId}
 * Generated by Decision Tapestry Agent Test Framework
 */

import { readDecisionsFile } from '../../shared/yaml-utils.js';
import { validateDecisionsFile } from '../agent-test-utils.js';

describe('Agent-${this.agentId}', () => {
    let decisionsData;
    
    beforeAll(async () => {
        // Load decisions data for testing
        decisionsData = await readDecisionsFile('decisions.yml');
    });

    describe('Schema Validation', () => {
        it('should maintain valid decisions.yml structure', async () => {
            const validation = await validateDecisionsFile();
            expect(validation.valid).toBe(true);
            if (!validation.valid) {
                console.error('Validation errors:', validation.errors);
            }
        });
    });

    describe('Decision Updates', () => {
        it('should have valid decision structure', () => {
            const decision = decisionsData.decisions.find(d => d.id === ${this.agentId});
            expect(decision).toBeDefined();
            expect(decision.id).toBe(${this.agentId});
            expect(decision.title).toBeDefined();
            expect(decision.status).toBeDefined();
        });
    });

    // Additional tests will be added here by the agent
});
`;
        
        await fs.writeFile(this.testFile, testContent);
        this.log('Test file initialized');
    }

    /**
     * Add a test case
     */
    addTest(description, testFunction, category = 'general') {
        this.tests.push({
            description,
            testFunction,
            category,
            generated: true
        });
        
        this.log(`Added test: ${description}`);
    }

    /**
     * Add schema validation test
     */
    addSchemaValidationTest(description, validationFunction) {
        this.addTest(description, validationFunction, 'schema');
    }

    /**
     * Add decision update test
     */
    addDecisionUpdateTest(description, updateFunction) {
        this.addTest(description, updateFunction, 'decision');
    }

    /**
     * Add file creation test
     */
    addFileCreationTest(filePath, expectedContent = null) {
        this.addTest(
            `should create file: ${filePath}`,
            async () => {
                const exists = await fs.access(filePath).then(() => true).catch(() => false);
                expect(exists).toBe(true);
                
                if (expectedContent) {
                    const content = await fs.readFile(filePath, 'utf8');
                    expect(content).toContain(expectedContent);
                }
            },
            'file'
        );
    }

    /**
     * Add integration test
     */
    addIntegrationTest(description, testFunction) {
        this.addTest(description, testFunction, 'integration');
    }

    /**
     * Generate test file with all added tests
     */
    async generateTestFile() {
        try {
            let testContent = await fs.readFile(this.testFile, 'utf8');
            
            // Group tests by category
            const testsByCategory = {};
            this.tests.forEach(test => {
                if (!testsByCategory[test.category]) {
                    testsByCategory[test.category] = [];
                }
                testsByCategory[test.category].push(test);
            });
            
            // Generate test code for each category
            let additionalTests = '';
            
            for (const [category, tests] of Object.entries(testsByCategory)) {
                if (category === 'general') continue; // Skip general category
                
                const categoryTitle = this.capitalize(category);
                additionalTests += `
    describe('${categoryTitle} Tests', () => {
${tests.map(test => this.generateTestCase(test)).join('\n')}
    });
`;
            }
            
            // Add general tests
            if (testsByCategory.general) {
                additionalTests += `
    describe('Agent-Generated Tests', () => {
${testsByCategory.general.map(test => this.generateTestCase(test)).join('\n')}
    });
`;
            }
            
            // Insert additional tests before the closing
            testContent = testContent.replace(
                '    // Additional tests will be added here by the agent',
                additionalTests + '\n    // Additional tests will be added here by the agent'
            );
            
            await fs.writeFile(this.testFile, testContent);
            this.log(`Generated test file with ${this.tests.length} tests`);
            
        } catch (error) {
            throw new Error(`Failed to generate test file: ${error.message}`);
        }
    }

    /**
     * Generate test case code
     */
    generateTestCase(test) {
        return `        it('${test.description}', async () => {
            ${this.generateTestBody(test)}
        });`;
    }

    /**
     * Generate test body based on test type
     */
    generateTestBody(test) {
        switch (test.category) {
            case 'schema':
                return `
            const validation = await validateDecisionsFile();
            expect(validation.valid).toBe(true);
            if (!validation.valid) {
                console.error('Validation errors:', validation.errors);
            }`;
                
            case 'decision':
                return `
            const decision = decisionsData.decisions.find(d => d.id === ${this.agentId});
            expect(decision).toBeDefined();
            expect(decision.status).toBeDefined();`;
                
            case 'file':
                return `
            // File existence and content validation
            const exists = await fs.access('${test.filePath}').then(() => true).catch(() => false);
            expect(exists).toBe(true);`;
                
            default:
                return `
            // Custom test implementation
            ${test.testFunction ? test.testFunction.toString() : 'expect(true).toBe(true);'}`;
        }
    }

    /**
     * Run all tests
     */
    async runTests() {
        try {
            this.log('Running tests...');
            
            // Generate test file first
            await this.generateTestFile();
            
            // Run Jest tests
            const testResults = await this.runJestTests();
            
            // Run integration tests if they exist
            await this.runIntegrationTests();
            
            this.log(`Tests completed: ${testResults.passed} passed, ${testResults.failed} failed`);
            
            return testResults;
            
        } catch (error) {
            throw new Error(`Test execution failed: ${error.message}`);
        }
    }

    /**
     * Run Jest tests
     */
    async runJestTests() {
        return new Promise((resolve, reject) => {
            const jest = spawn('npm', ['test', '--', this.testFile], {
                cwd: path.resolve(__dirname, '..'),
                stdio: 'pipe'
            });
            
            let output = '';
            let errorOutput = '';
            
            jest.stdout.on('data', (data) => {
                output += data.toString();
            });
            
            jest.stderr.on('data', (data) => {
                errorOutput += data.toString();
            });
            
            jest.on('close', (code) => {
                try {
                    const results = this.parseJestOutput(output);
                    
                    if (code === 0) {
                        resolve(results);
                    } else {
                        results.failed = results.total - results.passed;
                        results.error = errorOutput;
                        resolve(results);
                    }
                } catch (error) {
                    reject(error);
                }
            });
        });
    }

    /**
     * Parse Jest output to extract results
     */
    parseJestOutput(output) {
        const results = {
            passed: 0,
            failed: 0,
            total: 0,
            details: []
        };
        
        // Parse Jest output for test results
        const lines = output.split('\n');
        
        for (const line of lines) {
            if (line.includes('✓') || line.includes('PASS')) {
                results.passed++;
            } else if (line.includes('✗') || line.includes('FAIL')) {
                results.failed++;
            }
        }
        
        results.total = results.passed + results.failed;
        
        // If no specific results found, assume success if no errors
        if (results.total === 0 && !output.includes('FAIL')) {
            results.passed = 1;
            results.total = 1;
        }
        
        return results;
    }

    /**
     * Run integration tests
     */
    async runIntegrationTests() {
        try {
            const exists = await fs.access(this.integrationTestFile).then(() => true).catch(() => false);
            if (!exists) {
                this.log('No integration tests found');
                return;
            }
            
            this.log('Running integration tests...');
            
            const integrationResults = await this.runJestTests();
            this.log(`Integration tests: ${integrationResults.passed} passed, ${integrationResults.failed} failed`);
            
        } catch (error) {
            this.log(`Integration tests failed: ${error.message}`);
        }
    }

    /**
     * Create integration test file
     */
    async createIntegrationTestFile(testContent) {
        const fullTestContent = `/**
 * Integration tests for Agent-${this.agentId}
 * Tests the complete workflow and integration with other components
 */

import { readDecisionsFile } from '../../shared/yaml-utils.js';
import { validateDecisionsFile } from '../agent-test-utils.js';

describe('Agent-${this.agentId} Integration', () => {
    let decisionsData;
    
    beforeAll(async () => {
        decisionsData = await readDecisionsFile('decisions.yml');
    });

    ${testContent}
});
`;
        
        await fs.writeFile(this.integrationTestFile, fullTestContent);
        this.log('Integration test file created');
    }

    /**
     * Validate test results
     */
    validateResults(results) {
        if (results.failed > 0) {
            throw new Error(`${results.failed} tests failed`);
        }
        
        if (results.total === 0) {
            throw new Error('No tests were run');
        }
        
        return true;
    }

    /**
     * Get test status
     */
    getStatus() {
        return {
            agentId: this.agentId,
            testFile: this.testFile,
            testsGenerated: this.tests.length,
            results: this.testResults
        };
    }

    /**
     * Capitalize string
     */
    capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    /**
     * Log message
     */
    log(message) {
        const timestamp = new Date().toLocaleTimeString();
        console.log(`[${timestamp}] [Agent-${this.agentId}] [Tests] ${message}`);
    }
}